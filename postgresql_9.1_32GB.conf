# -----------------------------
# PostgreSQL configuration file 32GB
# -----------------------------
#
# This file consists of lines of the form:
#
# name = value
#
# Memory units:  kB = kilobytes        Time units:  ms  = milliseconds
#                MB = megabytes                     s   = seconds
#                GB = gigabytes                     min = minutes
#                                                   h   = hours
#                                                   d   = days

#------------------------------------------------------------------------------
# Расположение файлов
#------------------------------------------------------------------------------

# data_directory = 'ConfigDir'								# Определяет каталог, используемый для хранения данных.						
# hba_file = 'ConfigDir/pg_hba.conf'						# Определяет конфигурационный файл для аутентификации на основе хостов.									
# ident_file = 'ConfigDir/pg_ident.conf'					# Определяет конфигурационный файл для карт имён пользователей.
# external_pid_file = ''									# Определяет имя дополнительного PID (process-ID) файла, который сервер должен создать для использования программы управления сервером.

#------------------------------------------------------------------------------
# Подключения и аутентификация
#------------------------------------------------------------------------------

# - Настройки подключения -
listen_addresses = '*'										# Определяет TCP/IP адрес(а) на которых сервер ожидает подключения клиентов. '*' обозначает все доступные IP интерфейсы.
port = 5432													# Номер порта, который слушает сервер в ожидании соединений.
max_connections = 100										# Определяет максимальное количество одновременных подключений к серверу БД. Увеличение значения параметра max_connections потребует приблизительно 400 байт в разделяемой памяти на подключение, плюс блокировка пространства (смотрите max_locks_per_transaction). Так же вы должны увеличить параметр shared_buffers, чтобы принимать больше подключений. 
# superuser_reserved_connections = 3						# Число соединений, которые зарезервированы для суперпользователя, чтобы он мог всегда зайти, разобраться в чём дело, а затем принять меры. Не стоит совсем отказываться зарезервированных соединений, причём одного зарезервированного соединения может оказаться не достаточно - 2 это минимум.								
# unix_socket_directory = ''								# Определяет каталог Unix-domain socket, где сервер будет ожидать подключений от клиентских приложений. Значение по умолчанию - /tmp, но оно может быть изменено на этапе сборки.								
# unix_socket_group = ''									# Задаёт владельца группы Unix-domain socket. (Владельцем самого сокета всегда является пользователь, который запускает сервер). Вместе с параметром unix_socket_permissions он может использоваться как дополнительный механизм контроля подключений через unix-domain socket. По умолчанию значение этого параметра - пустая строка, что означает группу по умолчанию для пользователя сервера.
# unix_socket_permissions = 0777							# Задаёт права доступа к unix-domain socket, которые используют обычный механизм прав доступа к файлам. В качестве параметра ожидается число, которое задаёт формат доступа к файлу, используемое командами chmod и umask. (Для того, чтобы использовать восьмеричный формат ввода число должно начинаться с нуля (0)). Значение по умолчанию - 0777, что подразумевает, что любой может подключиться к сокету. Логичным значением так же может быть 0770 (разрешение подключения только владельцу файла и группе, см unix_socket_group) и 0700 (разрешение подключения только пользователю). (Обратите внимание, что для unix-domain socket важны разрешения только на запись, так что нет никакого смысла задавать или снимать разрешения на выполнение или чтение).
# bonjour = off												# Включает объявление о существовании сервера через Bonjour. По умолчанию - off							
# bonjour_name = ''											# Определяет имя Bonjour сервиса. Если в качестве параметра задана пустая строка (значение по умолчанию), то используется имя компьютера. Параметр игнорируется если сервер не был скомпилирован с поддержкой bonjour.

# - Безопасность и авторизация -
# authentication_timeout = 1min								# Максимальное время для завершения аутентификации клиента в секундах. Если потенциальный клиент за это время не завершил протокол аутентификации, то сервер завершает соединения. Это не позволяет зависшим клиентам занимать соединение.
# ssl = off													# Разрешает SSL соединения.
# ssl_ciphers = 'ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH'			# Определяет список SSL шифров, которые можно использовать для безопасных подключений.												
# ssl_renegotiation_limit = 512MB							# Определяет как много данных может быть передано по SSL-шифрованному соединения перед повторным обменом ключами. Повторный обмен ключами снижает шансы атакующего провести криптоанализ на большом объёме переданных данных, но так же и снижает производительность. В качестве лимита используется сумма переданных и полученных данных. Если этот параметр равен 0, то повторный обмен ключами не происходит. Значение по умолчанию - 512MB.
# password_encryption = on                              	# Когда пароль определён в CREATE USER или ALTER ROLE без ENCRYPTED или UNENCRYPTED, то этот параметр определяет, должне ли пароль быть зашифрован.
# db_user_namespace = off                               	# Этот параметр разрешает использовать отдельные пространства имён пользователей для каждой БД.

# - Kerberos and GSSAPI -
# krb_server_keyfile = ''                               	# Задаёт расположение файла ключа сервера Kerberos.
# krb_srvname = 'postgres'		                        	# Задаёт имя сервиса Kerberos.
# krb_caseins_users = off                               	# Определяет, надо ли рассматривать имена пользователей Kerberos и GSSAPI как регистрозависимые.

# - TCP Keepalives -
# tcp_keepalives_idle = 0									# Определяет количество секунд до отправки пакета keepalive по бездействующему каналу. Значение 0 использует системное значение. Этот параметр поддерживается только на системах, поддерживающих символы TCP_KEEPIDLE или TCP_KEEPALIVE и на Windows; на других системах это значение должно быть равно 0. Этот параметр игнорируется, если подключение происходит через unix-domain socket.				
# tcp_keepalives_interval = 0								# Определяет количество секунд между отправкой keepalive по бездействующему соединению. Значение 0 использует системное значение. Этот параметр поддерживается только на системах, поддерживающих символ TCP_KEEPINTVL и на Windows; на других системах это значение должно быть равно 0. Этот параметр игнорируется, если подключение происходит через unix-domain socket.						
# tcp_keepalives_count = 0									# Определяет количество пакетов keepalive, отправляемых по бездействующему соединению. Значение 0 использует системное значение. Этот параметр поддерживается только на системах, поддерживающих символ TCP_KEEPCONT; на других системах это значение должно быть равно 0. Этот параметр игнорируется, если подключение происходит через unix-domain socket.

#------------------------------------------------------------------------------
# Потребление ресурсов
#------------------------------------------------------------------------------

# - Память -
shared_buffers = 4096MB										# Размер разделяемой между процессами PostgreSQL памяти, которая нужна для выполнения активных операций. Не следует указывать слишком большой объём, так как PostgreSQL использует также дисковый кэш. 1/8 RAM или больше (но не более 1/4).			
temp_buffers = 16MB											# Буфер под временные объекты, в основном для временных таблиц. Можно установить порядка 16 МБ.
max_prepared_transactions = 0								# Количество одновременно подготавливаемых транзакций. Для работы 1С этот параметр значения не имеет, PREPARE TRANSACTION там не используются. Значение 0 (по умолчанию) отключает возможности создания подготовленных транзакций.
work_mem = 1536MB											# Специальная память, используется для сортировки и кэширования таблиц, для одного запроса. При задании этого параметра следует учитывать количество конкурентных запросов, выполняемых в один момент времени. 1/20 RAM.
maintenance_work_mem = 8192MB								# Память использующаяся для операций VACUUM, CREATE INDEX, ALTER TABLE и FOREGIN KEY. Следует устанавливать большее значение, чем для work_mem. Слишком большие значения приведут к использованию свопа. 1/4 RAM.
max_stack_depth = 16MB										# Идеальным значением этого параметра будет текущий лимит раздела стека, предоставляемый ядром (устанавливаемый через ulimit -s или что-то эквивалентное), менее безопасно - мегабайт или что-то вроде этого. Безопасное значение требуется поскольку глубина стека не проверяется в каждой процедуре на сервере, за исключением потенциальных рекурсивных процедур. Значение по умолчанию - 2MB, достаточно маленькое и при этом скорее всего не приводящее к падениям сервера. Однако оно может быть мало для выполнения сложных функций. Поставьте max_stack_depth такой же или вдвое меньше, чем ваш предел сервера (ulimit -s).

# - Использование ресурсов ядра -
max_files_per_process = 1000								# Максимальное количество файлов, открываемых процессом и его подпроцессами в один момент времени. Уменьшите данный параметр, если в процессе работы наблюдается сообщение "Too many open files".				
# shared_preload_libraries = ''								# Если для исполнения запроса требуется загрузить какую либо разделяемую библиотеку, то действует правило: загружаем при первом использовании, что замедляет исполнение самого первого такого запроса. Это можно обойти, загрузив необходимые библиотеке при старте сервера, то есть воспользоваться формулой: память в обмен на скорость.

# - Задержка vacuum на основе подсчёта нагрузки -
# Обычно нет необходимости заглядывать в этот раздел, так как сборка мусора (VACUUM) и анализ (ANALYZE) выполняются достаточно быстро.
# vacuum_cost_delay = 0ms									# Интервал времени, в миллисекундах, на который процесс заснёт при достижении лимита затрат. Значение по умолчанию - 0, то есть такая функциональность вообще отключена.
# vacuum_cost_page_hit = 1									# Ориентировочная стоимость очистки буфера, находящегося в общем буфере кеша. Представляет из себя затраты на блокировку буферного пула, просмотра общей хеш таблицы и сканирования содержимого страницы. Значение по умолчанию - 1.
# vacuum_cost_page_miss = 10								# Ориентировочная стоимость очистки буфера, который должен быть считан с диска. Представляет из себя затраты на блокировку буферного пула, просмотра общей хеш таблицы, считывания желаемого блока с диска и сканирования содержимого страницы. Значение по умолчанию - 10.
# vacuum_cost_page_dirty = 20								# Ориентировочная стоимость изменения vacuum'ом блока, который уже был очищен. Представляет из себя дополнительные затраты ввода / вывода, необходимые для сброса чистого блока на диск. Значение по умолчанию - 20.
# vacuum_cost_limit = 200									# Суммарная стоимость при достижении которой процесс очистки засыпает. Значение по умолчанию - 200.

# - Запись в фоне -
# bgwriter_delay = 200ms									# Определяет паузу между циклами активности background writer. В каждом цикле writer обслуживает некоторое количество "грязных" буферов (определяемое в других параметрах). После этого он засыпает на bgwriter_delaymilliseconds и всё начинается заново. Установка в качестве значения числа, которое не делится на 10 может иметь тот же эффект, что и ближайшее большее число, кратное 10.
# bgwriter_lru_maxpages = 100								# В каждом цикле не больше, чем это количество буферов может быть записано background writer'oм. Если установить в качестве значения 0, то background writer не будет записывать буферы, кроме как во веремя чекпойнтов. Значение по умолчанию - 100 буферов.
# bgwriter_lru_multiplier = 2.0								# Число "грязных" буферов, которые записываются в каждом цикле основывается на числе новых буферов, которые потребовались серверному процессу в последних циклах. Среднее количество недавно требовавшихся буферов умножается на bgwriter_lru_multiplier, в результате чего получается число буферов, которые потребуются в следующем цикле. "Грязные" буферы записываются до тех пор, пока число чистых, повторно используемых буферов не достигает нужного количества. (Но, в любом случае, будет записано не больше чем bgwriter_lru_maxpages буферов за цикл.) Таким образом, значение 1.0 означает подход "just in time", когда будет записано ровно столько буферов, сколько предположительно потребуется. Большие значения обеспечивают некий запас прочности на случай всплесков, тогда как меньшие означают, что мы намеренно оставляем запись на совесть серверных процессов. Значение по умолчанию - 2.0.

# - Асинхронное поведение -
effective_io_concurrency = 4								# Задаёт число операций ввода / вывода, которые, как PostgreSQL ожидает, будут выполняться одновременно. Увеличение этого значения увеличивает число операций ввода/вывода, которые одна сессия PostgreSQL будет пытаться провести параллельно. Допустимые значения - от 1 до 1000, или 0 для того, чтобы отключить асинхронные запросы ввода/вывода. Хорошим началом для  этой настройки будет число дисков, объединённых в RAID 0 или 1, которые используются для БД.

#------------------------------------------------------------------------------
# Журнал транзакций
#------------------------------------------------------------------------------

# - Настройки -
wal_level = minimal											# wal_level определяет как много информации будет записываться в WAL. Значение по умолчанию - minimal, что означает, что записывается только информация, необходимая для восстановления при крахе системы или "немедленном" выключении. archive добавляет логи, необходимые для WAL архивирования, а hot_standby добавляет ещё и информацию, необходимую для выполнения запросов на чтения с резервного сервера.			
fsync = on													# Данный параметр отвечает за сброс данных из кэша на диск при завершении транзакций. Если установить его значение fsync=off то данные не будут записываться на дисковые накопители сразу после завершения операций. Это может существенно повысить скорость операций insert и update, но есть риск повредить базу, если произойдет сбой (неожиданное отключение питания, сбой ОС, сбой дисковой подсистемы). Используйте эту возможность только если у вас имеются надежные ИБП и программное обеспечение, завершающее работу системы при низком заряде батарей.
synchronous_commit = off									# Доступные значения - on, local и off. Определяет, должна ли транзакция ждать, пока записи WAL будут перенесены на диск, прежде чем команда вернёт клиенту сообщение об успешном выполнении. По умолчанию и с точки зрения безопасности этот параметр должен быть включен. Если параметр выключен, возможен промежуток времени между сообщением об успешном выполнении транзакции и моментом, когда транзакция на самом деле защищена от сбоя на сервере. В отличие от fsync, отключение этого параметра не может привести к риску противоречия в базе данных: сбой может привести к потере последних прошедших транзакций, но состояние базы данных при этом будет таким, как будто эти транзакции просто были прерваны. Таким образом, отключение synchronous_commit может оказаться полезным, если производительность важнее, чем точность в проведении транзакций.
wal_sync_method = fdatasync									# Метод, который используется для принудительной записи данных на диск. Если fsync=off, то этот параметр не используется. open_datasync - запись данных методом open() с параметром O_DSYNC, fdatasync (default on Linux) - вызов метода fdatasync() после каждого commit, fsync_writethrough - вызывать fsync() после каждого commit игнорируя паралельные процессы, fsync - вызов fsync() после каждого commit, open_sync - запись данных методом open() с параметром O_SYNC
full_page_writes = on										# Установите данный параметр в off, если fsync=off. Когда этот параметр on, PostgreSQL записывает содержимое каждой страницы в журнал транзакций во время первой модификации таблицы после контрольной точки. Это необходимо потому что страницы могут записаться лишь частично если в ходе процесса ОС "упала". Это приводит к тому, что на диске оказаываются новые данные смешанные со старыми. Строкового уровня записи в журнал транзакций может быть не достаточно, что бы полность восстановить данные после "падения". full_page_writes гарантирует корректное восстановление, ценой увелечения записываемых данных в журнал транзакций. Потому что журнал транзакций все время начинается с контрольной точки. Единственный способ снижения объема записи заключается в увеличении checkpoint interval.
wal_buffers = 128MB											# Количество разделяемой памяти, используемой для WAL данных, которые ещё не были записаны на диск. Значение по умолчанию -1, что означает использование 1/32 (около 3%) shared_buffers, но не меньше 64kB и не больше размера сегмента WAL, обычно 16MB.
wal_writer_delay = 200ms									# Определяет  паузу между циклами активности WAL writer'a.  В каждом цикле writer записывает WAL на диск. После этого он засыпает на wal_writer_delay миллисекунд и снова начинает запись. Значение по умолчанию - 200 миллисекунд (200ms). Обратите внимание, что на многих системах шаг интервала должен быть 10 миллисекунд; задание значения  которое не кратно 10 может расцениваться как большее значение, кратное 10.
commit_delay = 100											# Когда данные транзакции записываются на диск, все другие транзакции, готовые к записи в это время тоже записываются на диск. commit_delay добавляет паузу, в микросекундах, перед тем, как транзакция будет записана на диск. Ненулевая задержка может привести к тому, что будет записано больше транзакций, если нагрузка на систему достаточна, чтобы дополнительные транзакции были готовы к записи. Поэтому пауза происходит только если хотя бы commit_siblings других транзакций активны на момент записи первой транзакции. Значением по умолчанию commit_delay является 0 (отсутствие задержки). Так как все отложенные данные будут записаны при каждой записи, вне зависимости от настройки, в редких случаях дополнительная пауза будет увеличивать производительность.
commit_siblings = 10										# Значение commit_siblings выражается в штуках (5 по умолчанию). commit_delay определяют задержку между попаданием записи в буфер журнала транзакций и сбросом её на диск. Если при успешном завершении транзакции активно не менее commit_siblings транзакций, то запись будет задержана на время commit_delay. Если за это время завершится другая транзакция, то их изменения будут сброшены на диск вместе, при помощи одного системного вызова. Эти параметры позволят ускорить работу, если параллельно выполняется много «мелких» транзакций.

# - Контрольные точки -
checkpoint_segments = 16									# Максимальное число сегментов лога между автоматическими чекпойнтами WAL (каждый сегмент, обычно - 16 мегабайт). Значение по умолчанию - 3 сегмента. Увеличение этого параметра может увеличить время, необходимое для восстановления после краха. Следует выделить столько, сколько не жалко, осознавая, что 32 сегмента займёт на диске свыше 1 Гб.
checkpoint_timeout = 10min									# Максимальный период времени между WAL чекпойнтами, в секундах. Значение по умолчанию - 5 минут (5min). Увеличение этого параметра может увеличить время, необходимое для восстановления после краха.
checkpoint_completion_target = 0.9							# Определяет время для завершения чекпойнта как долю от времени между чекпойнтами. Значение по умолчанию - 0.5.
checkpoint_warning = 30s									# Если кэш а диске заполняется быстрее чем число секунд checkpoint_warning (что подразумевает, что checkpoint_segments должно быть увеличено), то посылается предупреждение, которое будет передано в журнальный файл. Значение по умолчанию - 30 секунд (30s). 0 отключает предупреждения.

# - Архивирование -
# archive_mode = off										# Когда активирована эта настройка, завершённые сегменты WAL отправляются в архив, заданный archive_command. archive_mode и archive_command - разные параметры, так что каждый из них может быть изменён независимо. archive_mode не может быть активирован, если wal_level = minimal.
# archive_command = ''										# Команда оболочки, которая выполняется для архивирования файловых сегментов WAL. %p в строке будет заменён на путь к файлу архива, а %f - на имя файла архива. (Путь задаётся относительно рабочего каталога сервера, т.е. каталога данных). Для того, чтобы использовать знак % замените его на %%. Важно, чтобы команда возвращала 0 в качестве статуса завершения только в случае благополучного выполнения команды.
# archive_timeout = 0										# Принудительно переключать сегмент в лог файле по истечению времени. 0 - выключено.

#------------------------------------------------------------------------------
# Репликация
#------------------------------------------------------------------------------

# - Мастер -
# max_wal_senders = 0										# Определяет максимальное количество одновременных подключений от резервных серверов или клиентов потокового резервного копирования (т.е. максимальное количество одновременно запущенных процессов отправителей WAL). Значение по умолчанию - 0. wal_level должен быть установлен в archive или hot_standby, чтобы разрешить подключения от резервных серверов.					
# wal_sender_delay = 1s										# Определяет задержку между циклами активности процессов отправителей WAL. В каждом цикле отправитель WAL посылает все WAL, собранные с последнего цикла, на резернвый сервер. После этого процесс засыпает на wal_sender_delay и цикл начинается заново. Сон прерывается подтверждением транзакции, так что подтверждённые транзакции отправляются на резервные сервера сразу после подтверждения, вне зависимости от этой настройки.
# wal_keep_segments = 0										# Определяет минимальное число файлов сегментов лога, хранимых в каталоге pg_xlog, в случае если резервный сервер должен получить их для потоковой репликации. Каждый сегмент обычно равен 16 мегабайт. Если резервный сервер отстаёт от мастера больше чем на wal_keep_segments сегментов, то мастер удалит нужные сегменты WAL и в таком случае подключение репликации будет прервано. (Однако, резервный сервер может затем восстановить эти сегменты из архива, если происходит архивирование WAL).
# vacuum_defer_cleanup_age = 0								# Определяет число транзакций, по которым VACUUM и HOT обновления будут определять очистку версий мёртвых строк. Значение по умолчанию - 0 транзакций, что означает, что версии мёртвых строк будут удалены как только появится возможность, то есть как только они не видны ни одной открытой транзакции.
# replication_timeout = 60s									# Соединения репликации, неактивные больше чем заданное тут время в миллисекундах, разрываются. Это полезно для мастера для обнаружения проблем в сети и сбоя резервного сервера. Значение, равное 0, отключает этот механизм. Для того, чтобы соединения не разрывались, wal_receiver_status_interval должен быть активирован на резервном сервере и это значение должно быть меньше, чем replication_timeout.
# synchronous_standby_names = ''							# Значением параметра является список, с разделителями запятыми, который содержит имена резервных серверов, которые поддерживают синхронную репликацию. 
								
# - Резервные сервера -
# Эти настройки определяют поведение резервных серверов, которые должны получать данные для репликации. Их значение на мастере не имеет никакого значения.
# hot_standby = off											# Определяет, можете ли Вы подключиться для выполнения запросов к серверу во время восстановления.
# max_standby_archive_delay = 30s							# Когда активен режим "горячего" резервного сервера, этот параметр определяет как долго резервный сервер должен ждать перед отменой запроса к нему, если этот запрос конфликтует с записями WAL, которые должны быть сейчас применены. Значение по умолчанию - 30 секунд. Единица измерения - миллисекунды, если не определено иначе. Значение -1 позволяет резервному серверу вечно ждать завершения конфликтующего запроса.
# max_standby_streaming_delay = 30s							# Когда активен режим "горячего" резервного сервера, этот параметр определяет как долго резервный сервер должен ждать перед отменой запроса к нему, если этот запрос конфликтует с записями WAL, которые должны быть сейчас применены. max_standby_streaming_delay применяется когда WAL данные получаются через потоковую репликацию. Значение по умолчанию - 30 секунд. Единица измерения - миллисекунды, если не определено иначе. Значение -1 позволяет резервному серверу вечно ждать завершения конфликтующего запроса.
# wal_receiver_status_interval = 10s						# Определяет минимальную частоту, с которой процесс получения WAL на резервном сервере будет посылать на мастер информацию о прогрессе репликации, который можно увидеть при помощи pg_stat_replication. Резервный сервер сообщает последнюю позицию в логе транзакций, которая была записана, последняя позиция, сброшенная на диск и последняя применённая позиция. Значением этого параметра является максимальный интервал, в секундах, между отчётами. Обновления посылаются каждый раз, когда изменяется позиция записи или сброса на диск, или, не позже, чем указанное тут время. Таким образом, реальная применённая позиция может немного отличаться от переданной. Установка этого параметра в 0 отключает обновление статуса. Когда активирован replication_timeout на мастере, wal_receiver_status_interval тоже должен быть активирован и его значение должно быть меньше, чем replication_timeout.
# hot_standby_feedback = off								# Определяет, будет или нет "горячий" резервный сервер посылать "отзыв" (feedback) мастеру по поводу запросов, которые сейчас выполняются на резервном сервере. Этот параметр может быть использован для того, чтобы запросы не прекращались из-за очистки записей, но может увеличить нагрузку на мастер. "Отзывы" не будут посылаться чаще, чем 1 отзыв в wal_receiver_status_interval интервал. Значение по умолчанию - off.

#------------------------------------------------------------------------------
# Планирование запросов
#------------------------------------------------------------------------------

# - Конфигурация метода планировщика -
# enable_bitmapscan = on 									# Разрешает или запрещает планировщику запросов использовать типы планов с участием bitmap-сканнирования (bitmap-scan). Значение по умолчанию on.
# enable_hashagg = on 										# Разрешает или запрещает планировщику запросов использовать типы планов с участием аггрегирования на основе хэширования (hashed aggregation). Значение по умолчанию on.
# enable_hashjoin = on 										# Разрешает или запрещает планировщику запросов использовать типы планов с участием операции соединения на основе хэширования (hash-join). Значение по умолчанию on.
# enable_indexscan = on 									# Разрешает или запрещает планировщику запросов использовать типы планов с участием индексного сканнирования (index-scan). Значение по умолчанию on.
# enable_material = on 			
# enable_mergejoin = on 									# Разрешает или запрещает планировщику запросов использовать типы планов с участием операции соединения методом слияния (merge-join). Значение по умолчанию on.
# enable_nestloop = on										# Разрешает или запрещает планировщику запросов использовать планы с участием операции соединения с вложенными циклами (nested-loop join). Совсем заблокировать операции соединения с вложенными циклами невозможно, но если установить этой переменной запрещающее значение, планировщик не будет использовать этот метод, если будет доступен какой-либо другой. Значение по умолчанию on.
# enable_seqscan = on 										# Разрешает или запрещает планировщику запросов использовать типы планов с участием операций последовательного чтения (sequential scan). Совсем заблокировать операции последовательного чтения невозможно, но если установить этой переменной запрещающее значение, планировщик не будет использовать этот метод, если будет доступен какой-либо другой. Значение по умолчанию on.
# enable_sort = on 											# Разрешает или запрещает планировщику запросов использовать шаги явной сортировки (explicit sort steps). Совсем заблокировать явную сортировку невозможно, но если установить этой переменной запрещающее значение, планировщик не будет использовать этот метод, если будет доступен какой-либо другой. Значение по умолчанию on.
# enable_tidscan = on 										# Разрешает или запрещает планировщику запросов использовать типы планов с участием операции TID-сканнирования (TID scan). Значение по умолчанию on.

# - Стоимостные константы планировщика -
seq_page_cost = 1.0											# Устанавливает у планировщика оценку "стоимоти" последовательного перебора данных. По умолчанию 1.0.
random_page_cost = 4.0										# Устанавливает у планировщика оценку "стоимоти" не последовательного перебора данных. По умолчанию 4.0. Уменьшение этого значения по отношению к seq_page_cost вызовет у планировщика предпочтение сканирования индекса, увеличение - наоборот сделает сканирование индекса "дороже". Вы можете изменить оба значения чтобы изменить отношение "стоимости" дисковых операций ввода/выдода, по отношению к "стоимости" использования процессора, которая будет описана следующими параметрами. На серверах с быстрыми дисковыми массивами имеет смысл уменьшать изначальную настройку до 3.0, 2.5 или даже до 2.0. Если же активная часть вашей базы данных много больше размеров оперативной памяти, попробуйте поднять значение параметра. Можно подойти к выбору оптимального значения и со стороны производительности запросов. Если планировщик запросов чаще, чем необходимо, предпочитает последовательные просмотры (sequential scans) просмотрам с использованием индекса (index scans), понижайте значение. И наоборот, если планировщик выбирает просмотр по медленному индексу, когда не должен этого делать, настройку имеет смысл увеличить. После изменения тщательно тестируйте результаты на максимально широком наборе запросов. Никогда не опускайте значение random_page_cost ниже 2.0. Если вам кажется, что random_page_cost нужно еще понижать, разумнее в этом случае менять настройки статистики планировщика. 2 для быстрых cpu, 4 для медленных.
cpu_tuple_cost = 0.01										# Устанавливает у планировщика оценку "стоимоти" затрат на обработку каждой строки во время выполнения запроса. По умолчанию 0,01. 0.001 для быстрых cpu, 0.01 для медленных. В 100 раз быстрее seq_page_cost.
cpu_index_tuple_cost = 0.005								# Устанавливает у планировщика оценку "стоимоти" затрат на обработку каждого индекса во время операции сканирования индекса. По умолчанию 0,005. 0.0005 для быстрых cpu, 0.005 для медленных. В 1000 раз быстрее seq_page_cost.
cpu_operator_cost = 0.0025									# Устанавливает у планировщика оценку "стоимоти" затрат на выполнение каждого оператора или функции во время выполнения запроса. По умолчанию 0.0025. В 400 раз быстрее seq_page_cost.
effective_cache_size = 16GB									# Передает данные планировщику запросов об объёме памяти, которая используется ОС для кэширования файлов, для одного запроса. Для Linux: наберите команду free, необходимое значение в столбце cached (в kB). Данное значение необходимо разделить на количество конкурентных запросов в один момент времени (среднее количество подключений к базе + запас). 0.9 от значения cached, которое показывает free.

# - Оптимизатор запросов на основе генетического алгоритма -
# geqo = on 												# Разрешает или запрещает оптимизацию запросов на основе генетического алгоритма (genetic query optimization), то есть алгоритма, который пытается планировать запросы без проведения полного поиска. По умолчанию эта опция включена. С помощью переменной geqo_threshold можно выборочно запретить GEQO для определённых классов запросов.
# geqo_threshold = 12 										# Использовать GEQO для планирования запросов с по меньшей мере таким количеством элементов FROM. (Обратите внимание, конструкция FULL OUTER JOIN считается за один элемент FROM.) Значение по умолчанию равно 12. Для простых запросов лучше использовать детерминированный, полный планировщик, но для запросов с большим количеством таблиц детерминированный планировщик будет работать слишком долго.
# geqo_effort = 5 											# Контролирует соотношение между временем планирования и эффективностью плана в GEQO. Значением этой переменной может быть целое число в интервале от 1 до 10. По умолчанию установлено 5. Большие значения повышают время на планирование запроса, но и увеличивают вероятность выбора эффективного плана.
# geqo_pool_size = 0 										# Контролирует размер пула, используемого GEQO. Размер пула — это число жителей в генетической популяции. Их должно быть как минимум 2, но полезные значения лежат в диапазоне от 100 до 1000. Если указать 0 (по умолчанию), то будет автоматически выбрано подходящее значение на основе geqo_effort и числа таблиц в запросе.
# geqo_generations = 0 										# Контролирует число поколений, используемых GEQO. Это число определяет количество итераций в алгоритме. Должно быть как минимум 1, но полезные значения лежат в том же диапазоне, что и размер пула. Если указать 0 (по умолчанию), то подходящее значение будет выбрано на основе geqo_pool_size.
# geqo_selection_bias = 2.0 								# Контролирует смещение селекции, используемой GEQO. Смещение селекции — это селективное влияние внутри популяции. Значения могут лежать в диапазоне от 1.50 до 2.00 (последнее — по умолчанию).
# geqo_seed = 0.0

# - Другие опции планировщика -
default_statistics_target = 100								# Устанавливает глубину статистики по таблицам. БОльшие значения могут повысить время выполнения команды ANALYZE, но улучшат построение плана запроса. Рекомендуется устанавливать порядка 100.
constraint_exclusion = on									# Разрешает или запрещает планировщику запросов использовать для оптимизации запросов ограничения таблиц. Допустимые значения параметра constraint_exclusion: on (проверять ограничения для всех таблиц), off (никогда не проверять ограничения), partition (проверять ограничения только для дочерних таблиц при наследовании и UNION ALL подзапросов). Значение по умолчанию partition.
# cursor_tuple_fraction = 0.1 								# Задаёт оценку планировщика для количества строк, которые будут выбраны курсором. Значение по умолчанию 0.1. Меньшие значения этого параметра будут склонять планировщик к использованию для курсоров планов "быстрого старта". Тогда первые несколько строк будут получены быстро, а получение оставшихся может занять гораздо больше времени. Большие значения нужно ставить, если для вас важнее полное оценочное время. При максимальном значении (1.0) курсоры планируются точно так же, как обычные запросы, когда во внимание принимается только общее оценочное время, а не как быстро могут быть получены первые строки.
# from_collapse_limit = 8 									# Планировщик будет сливать подзапросы в запросы более высокого уровня, если итоговый список FROM будет содержать не более такого количества элементов. Меньшие значения уменьшают время планирования, но могут ухудшить его качество. Значение по умолчанию равно 8. Обычно значение этого параметра берут ниже, чем geqo_threshold.
join_collapse_limit = 1										# Планировщик будет переписывать явные конструкции JOIN (кроме FULL JOIN) в списки элементов FROM, если количество элементов списка будет не более этого числа. Меньшие значения уменьшают время планирования, но могут ухудшить его качество. По умолчанию значение этой переменной равно значению параметра from_collapse_limit, что подходит в большинстве случаев. Значение, равное 1, означает, что не будет перегруппировки явных JOIN. Таким образом, порядок явных операций соединения, определённый в запросе, останется реальным порядком, в котором будут соединяться отношения. Планировщик запросов не всегда использует оптимальный порядок соединений, продвинутые пользователи могут временно установить этой переменной значение 1 и затем явно задать порядок соединений, который им необходим.

#------------------------------------------------------------------------------
# Сообщения об ошибках и ведение журнала
#------------------------------------------------------------------------------

# - Местоположение журнального файла -
log_destination = 'syslog'									# Куда сохранять информацию. Возможные значение: stderr, csvlog, syslog and eventlog, зависят от платформы. csvlog требует, чтобы logging_collector был включен.
logging_collector = off										# Этот параметр позволяет сообщениям, отправленным в stderr и журнал в формате CSV, быть перехваченными и направленными в файлы журнала.
# log_directory = 'pg_log'									# Если включена опция logging_collector, этот параметр определяет директорию, в которой будут создаваться файлы журнала. Можно указать абсолютный путь или путь относительно директории данных кластера.
# log_filename = 'postgresql-%a.log'						# Если включена опция logging_collector, этот параметр задаёт имена файлов для журнала.
# log_file_mode = 0600										# Если включена опция logging_collector, этот параметр задаёт права на лог файл.
# log_truncate_on_rotation = on								# Если включена опция logging_collector, этот параметр заставит PostgreSQL заменять (переписывать) любой существующий файл журнала при совпадении имени, а не добавлять записи в него.
# log_rotation_age = 1d										# Если включена опция logging_collector, этот параметр определяет максимальное время жизни отдельного файла журнала. После этого числа минут создаётся новый файл журнала. Если вы хотите запретить создание новых файлов по времени, укажите значение 0.
# log_rotation_size = 0										# Если включена опция logging_collector, этот параметр определяет максимальный размер отдельного файла журнала. После того, как в файл журнала внесено такое число килобайт, создаётся новый файл. Чтобы отключить эту возможность, укажите значение 0.
syslog_facility = 'LOCAL0' 									# Если разрешена запись в syslog, этот параметр определяет, каким "инструментом" syslog будет пользоваться. Можно выбрать из LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7, по умолчанию стоит LOCAL0.
syslog_ident = 'postgres' 									# Если разрешена запись в syslog, этот параметр определяет имя программы, используемой для идентификации сообщений PostgreSQL в журналах syslog. По умолчанию это postgres.
# silent_mode = off											# "Тихий" запуск сервера (без сообщений). Если эта опция включена, запуск сервера произойдёт автоматически, в фоновом режиме, при этом, ассоциированные с ним управляющие терминалы будут отсутствовать. Стандартные выводы сообщений и ошибок сервера перенаправляются в /dev/null, то есть, все сообщения, посылаемые в них, будут утеряны. Если не выбрана запись в syslog или не включена опция logging_collector, использовать этот параметр бессмысленно, так как это мешает видеть сообщения об ошибках.

# - Уровень информативности -
# client_min_messages = notice								# Характеризует уровень подробности сообщений отсылаемых клиенту (debug5|debug4|debug3|debug2|debug1|log|notice|warning|error).
log_min_messages = warning									# Характеризует уровень подробности записей в журнальный файл (debug5|debug4|debug3|debug2|debug1|info|notice|warning|error|log|fatal|panic).
log_min_error_statement = error								# Характеризует уровень подробностей записей в журнальный файл создаваемых в результате исполнения SQL-запросов (debug5|debug4|debug3|debug2|debug1|info|notice|warning|error|log|fatal|panic).
# log_min_duration_statement = -1							# Устанавливает минимальное время (в миллисекундах) выполнения запроса, который попадает в лог. -1 - выключено.

# - Что писать в лог -

# Эти параметры разрешают запись информации отладчика. Для каждого выполняемого запроса они выдают итоговое дерево разбора, результат работы переписчика запросов или план выполнения. Эти сообщения выдаются на уровне LOG, поэтому по умолчанию они будут занесены в журнал сервера, но не будут отправлены клиенту. Это можно изменить, настроив client_min_messages и/или log_min_messages. По умолчанию эти параметры отключены.
# debug_print_parse = off
# debug_print_rewritten = off
# debug_print_plan = off

# debug_pretty_print = on            						# Если эта опция включена (по умолчанию включена), debug_pretty_print помечает сообщения, созданные debug_print_parse, debug_print_rewritten или debug_print_plan. Это приводит к тому, что записи становятся более читаемыми, но и более длинными, чем в "компактном" формате, используемом, если эта опция отключена.
# log_checkpoints = off										# В лог будет попадат информация о checkpoint'ах.
# log_connections = off										# В лог будет попадать информация о новых подключениях к PostgreSQL.
# log_disconnections = off									# В лог будет попадать информация об отключениях от PostgreSQL.
# log_duration = off										# Включает логирование запросов.
# log_error_verbosity = default 							# Контролирует количество деталей, вносимых в журнал сервера для каждого записываемого сообщения. Возможные значения: TERSE, DEFAULT и VERBOSE, каждое добавляет больше полей к отображаемым сообщениям.
# log_hostname = off 										# По умолчанию сообщения в журнале, касающиеся соединений, показывают только IP-адрес соединяющегося узла. Включение этой опции приводит к сохранению также и имени узла. Заметим, что при этом может произойти заметное ухудшение производительности.
# log_line_prefix = ''										# Специальные значения: (%u = имя пользователя|%d = имя БД|%r = удаленный хост и порт|%h = удаленный хост|%p = идентификатор процесса|%t = время без миллисекунд|%m = время с миллисекундами|%i = command tag|%c = идентификатор сессии|%l = session line number|%s = время старта сессии|%v = идентификатор виртуальной транзакции|%x = идентификатор транзакции)
# log_lock_waits = off										# В лог будет попадать информация о длительных ожиданиях сессий в попытке получить блокировку на объекте.
# log_statement = 'none'									# Позволит выводить в лог все SQL запросы (none - журналирование отключено, ddl - команды определения данных (создание БД, таблиц, пользователей и т.п.), mod - все что связано с модификацией данных (включая DDL-команды), all - в журнал записывается абсолютно все общение сервера с клиентами).
# log_temp_files = -1										# В лог будет попадать информация о временных файлах. -1 - выключено. 0 - логировать все временные файлы.
log_timezone = 'Europe/Kaliningrad'

#------------------------------------------------------------------------------
# Сбор статистики
#------------------------------------------------------------------------------

# - Сборщик статистики запросов и индексов -
# track_activities = on       								# Передавать ли сборщику статистики информацию о текущей выполняемой команде и времени начала её выполнения. По умолчанию эта возможность включена.
# track_counts = on    										# Включать ли сбор статистики. По умолчанию включён, поскольку autovacuum демону требуется сбор статистики. Отключайте, только если статистика вас совершенно не интересует (как и autovacuum).
# track_functions = none									# Отслеживание использования определенных пользователем функций. Может принимать значения: none, pl, all.
# track_activity_query_size = 1024 							# Задаёт число байтов для поля pg_stat_activity.current_query, зарезервированное для отслеживания текущей выполняемой команды в каждой активной сессии. По умолчанию 1024 байта.
# update_process_title = on 								# Разрешает обновление заголовка процесса каждый раз, когда сервер получает новую SQL-команду. Заголовок процесса можно посмотреть с помощью команды ps, а в Windows с помощью Process Explorer.
# stats_temp_directory = 'pg_stat_tmp' 						# Задаёт директорию, в которой будут храниться временные статистические данные. Значением может быть путь относительно директории данных или абсолютный путь. Значение по умолчанию pg_stat_tmp. Использование этой опции в RAM-based файловых системах увеличит требования к физическому I/O и может улучшить производительность.

# - Мониторинг статистики -

# Для каждого запроса писать в журнал статистику производительности соответствующего модуля. Это грубый инструмент профайлинга. log_statement_stats выдаёт полную статистику по оператору, остальные выдают статистику по соответствующим модулям. Опция log_statement_stats не может быть включена одновременно с какой-либо из оставшихся трёх. По умолчанию все эти опции отключены.
# log_parser_stats = off
# log_planner_stats = off
# log_executor_stats = off
# log_statement_stats = off

#------------------------------------------------------------------------------
# Автоматическая сборка мусора
# VACUUM - сборка "мусора". VACUUM восстанавливает место занятые "мертвыми" данными. При выполнении обычных операций с данными,
# PostgreSQL не удаляет данные физически из таблиц, это происходит с операцией VACUUM.
#------------------------------------------------------------------------------

autovacuum = off											# Включать ли автовакуум (автоматического запуска VACUUM), устанавливать on. Требует включенного параметра track_counts.
# log_autovacuum_min_duration = -1							# Установка равная нулю регистрирует все действия autovacuum. -1 (по умолчанию) запрещает вывод в лог. Например, если вы установите значение равное 250 мс, то все действия autovacuum и analyzes, которые работают 250 мс и более, будут заноситься в журнал.
# autovacuum_max_workers = 3								# Максимальное кол-во autovacuum процессов
# autovacuum_naptime = 10min								# Пауза между запусками Автовакуума. Зависит от того, как часто обновляются данные в ваших таблицах. Может соствлять порядка 5min, по умолчанию 1min
# autovacuum_vacuum_threshold = 1800						# Порог на число удалённых и изменённых записей в любой таблице по превышению которого происходит сборка мусора (VACUUM). Этот параметр может быть изменен для отдельных таблиц путем изменения параметров хранения.
# autovacuum_analyze_threshold = 1800						# Порог на число вставленных, удалённых и изменённых записей в любой таблице по превышению которого запускается процесс анализа (ANALYZE). Этот параметр может быть изменен для отдельных таблиц путем изменения параметров хранения.
# autovacuum_vacuum_scale_factor = 0.2						# При изменении или удалении записей 0.2 = 20% от размера таблицы для того, чтобы autovacuum вызвал команду VACUUM на эту таблицу. Значение по умолчанию равно 0.4.
# autovacuum_analyze_scale_factor = 0.1						# При изменении или удалении записей 0.1 = 10% от размера таблицы для того, чтобы autovacuum вызвал команду ANALYZE на эту таблицу. Значение по молчанию равно 0.2.
# autovacuum_freeze_max_age = 200000000						# Максимальный возраст таблицы, то есть разница её предыдущей ID транзакции с текущей, при превышении будет выполнен запуск autovacuumа.
# autovacuum_vacuum_cost_limit = -1							# Указывает значение предела стоимости при использовании autovacuumа.

#------------------------------------------------------------------------------
# Значения по умолчанию для соединений клиентов
#------------------------------------------------------------------------------

# - Поведение операторов -
# search_path = '"$user",public' 							# Эта переменная задаёт порядок, в котором производится поиск по схемам, если на объект (таблица, тип данных, функция и т.д.) ссылаются только по имени, без указания компонентов схемы. Если в различных схемах есть объекты с одинаковыми именами, используется тот, который был найден раньше. На объект, который не принадлежит ни одной схеме в пути поиска, можно ссылаться только указав содержащую его схему с помощью классифицированного имени (с точкой).
# default_tablespace = ''									# Эта переменная задаёт табличное пространство по умолчанию, в котором должны создаваться объекты (таблицы и индексы), если в команде CREATE явно не указано табличное пространство.
# temp_tablespaces = '' 									# Эта переменная задаёт табличные пространства, в которых будут создаваться временные объекты (временные таблицы и индексы во временных таблицах), если в команде CREATE явно не указано табличное пространство. Временные файлы, используемые для сортировки больших объёмов данных также будут создаваться в этих табличных пространствах.
# check_function_bodies = on 								# Обычно эта опция включена. Если указать значение off, будет отключена валидация тела функции при выполнении команды CREATE FUNCTION. Иногда отключение валидации может быть полезным, например, чтобы избежать проблем, связанных с прямыми ссылками при восстановлении определения функции из дампа.
# default_transaction_isolation = 'read committed' 			# Каждая SQL-транзакция имеет уровень изоляции, который может быть "read uncommitted", "read committed", "repeatable read" или "serializable". Этот параметр контролирует уровень изоляции по умолчанию для каждой новой транзакции. Значение по умолчанию "read committed".
# default_transaction_read_only = off 						# SQL-транзакция "только для чтения" не может изменять не-временные таблицы. Этот параметр контролирует статус по умолчанию для каждой новой транзакции. Значение по умолчанию off (read/write).
# default_transaction_deferrable = off
# session_replication_role = 'origin' 						# Контролирует запуск триггеров и правил, относящихся к репликации, для текущей сессии. Изменение этой переменной требует прав суперпользователя и приведёт к потере всех планов запросов, которые были в кэше. Возможные значения: origin (по умолчанию), replica и local.
# statement_timeout = 0										# Прервать работу оператора, которая длится более указанного числа миллисекунд начиная с момента получения сервером команды от клиента. Если значение параметра log_min_error_statement ERROR или ниже, остановленный оператор также будет записан в журнал. Значение 0 (по умолчанию) отключает это ограничение.
# vacuum_freeze_min_age = 50000000 							# Задаёт возраст отключения (в транзакциях), которое должен использовать VACUUM для решения, заменять ли ID транзакции на FrozenXID при сканировании таблицы. Значение по умолчанию 100 миллионов транзакций. Хотя, пользователи могут указать любое значение от 0 до 1 миллиарда, VACUUM негласно ограничивает эффективное значение до половины значения параметра autovacuum_freeze_max_age, чтобы между вынужденными операциями автовакууминга не был слишком маленький промежуток времени.
# vacuum_freeze_table_age = 150000000
# bytea_output = 'hex'										# Устанавливает формат вывода значений типа BYTEA. Может принимать значения: hex, escape.
# xmlbinary = 'base64' 										# Задаёт, как кодировать бинарные значения в XML. Это применяется, например, когда данные типа bytea конвертируются в XML с помощью функции xmlelement или xmlforest. Возможные значения: base64 и hex, оба определены в стандарте XML Schema. Значение по умолчанию base64.
# xmloption = 'content' 									# Указывает, что подразумевается, DOCUMENT или CONTENT, при конвертировании из XML в строку символов и наоборот. См. также Section 8.13. Возможные значения: DOCUMENT и CONTENT. Значение по умолчанию CONTENT.

# - Локаль и форматирование -
datestyle = 'iso, dmy' 										# Задаёт формат отображения даты и времени, как и правила интерпретирования двусмысленных значений даты.
# intervalstyle = 'postgres' 								# Задаёт формат отображения для интервальных значений. Если указать значение sql_standard, выдаваемые интервальные символы будут соответствовать SQL-стандарту. Значение postgres (по умолчанию) означает, что отображение будет соответствовать PostgreSQL до версии 8.4, где параметр DateStyle имеет значение ISO. Если указать postgres_verbose, результаты будут соответствовать PostgreSQL до версии 8.4, где параметр DateStyle настроен на не-ISO результат. Значение iso_8601 соответствует отображению интервалов времени в формате с обозначениями ("format with designators"), определённом в разделе 4.4.3.2 в ISO 8601.
timezone = 'Europe/Kaliningrad'								# Задаёт часовой пояс для отображения и интерпретирования временных пометок. Значение по умолчанию unknown. Это означает, что будет взят часовой пояс, используемый в системном окружении.
# timezone_abbreviations = 'Default'     					# Задаёт набор аббревиатур часовых поясов, который будет приниматься сервером для ввода даты и времени. Значение по умолчанию 'Default', набор, который работает практически по всему миру, кроме того, есть 'Australia' и 'India', и для каждого конкретного случая можно определить свои наборы.
# extra_float_digits = 0									# Этот параметр настраивает количество разрядов, показываемых для чисел с плавающей точкой, включая float4, float8 и геометрические типы данных. Значение этого параметра добавляется к стандартному количеству разрядов (FLT_DIG или DBL_DIG). Можно выбирать значение до 2, и таким образом будут включены частично значимые разряды. Это полезно при дампе данных с плавающей точкой, которые должны быть восстановлены точно. Если вы хотите убрать лишние разряды, можно указать этому параметру отрицательное значение.
# client_encoding = sql_ascii								# Задаёт кодировку (набор символов) для клиента. По умолчанию используется та же кодировка, что и у базы данных.

# Эти настройки создются при выполнении initdb, но они могут быть изменены.
lc_messages = 'ru_RU.UTF-8'									# Задаёт язык вывода сообщений.
lc_monetary = 'ru_RU.UTF-8'									# Задаёт локаль, в формате которой нужно будет записывать денежные значения.
lc_numeric = 'ru_RU.UTF-8'									# Задаёт локаль, используемую для форматирования чисел.
lc_time = 'ru_RU.UTF-8'										# Задаёт локаль, используемую для форматирования значений даты и времени.

# Настройки по умолчанию для полнотекстового поиска
default_text_search_config = 'pg_catalog.russian' 			# Выбирает конфигурацию текстового поиска, используемую теми вариантами функций текстового поиска, в которых нет явного аргумента, определяющего эту конфигурацию.

# - Другие значения по умолчанию -
# dynamic_library_path = '$libdir' 							# Если должен быть открыт динамически подгружаемый модуль, а имя файла, заданное в команде CREATE FUNCTION или LOAD не содержит название директории (то есть в имени файла нет косой черты), система будет искать требуемый файл по указанному пути.
# local_preload_libraries = '' 								# В этой переменной можно задать одну или несколько разделённых библиотек, которые будут предзагружены при запуске сервера. Если необходимо загрузить несколько библиотек, перечислите их имена через запятую. Значение этого параметра нельзя изменять после начала сессии.

#------------------------------------------------------------------------------
# Управление блокировками
#------------------------------------------------------------------------------

deadlock_timeout = 2s										# Время в миллисекундах, которое необходимо подождать в блокировке при проверке, не возник ли deadlock. Проверка на deadlock является относительно медленной, поэтому сервер не запускает её каждый раз, когда ждёт блокировки. Мы оптимистично предполагаем, что deadlock не является нормой при создании приложений, и просто немного ждём, прежде чем начинать проверку на deadlock. Установить порядка 2 секунд.
max_locks_per_transaction = 250								# Количество блокировок за одну транзакцию. Установить порядка 250.
# max_pred_locks_per_transaction = 64

#------------------------------------------------------------------------------
# Совместимость версий и платформ
#------------------------------------------------------------------------------

# - Предыдущие версии PostgreSQL -
# array_nulls = on 											# Контролирует, считает ли анализатор вводимых данных неквотированные NULL пустыми элементами массива. Значение по умолчанию on, что позволяет добавлять массивы, содержащие пустые элементы. Однако, PostgreSQL версии до 8.2 не поддерживает пустые значения в массивах, и, следовательно, будет воспринимать NULL как нормальный элемент массива со значением "NULL" типа string. Для обратной совместимости с приложениями, написанными с учётом старого поведения, эту опцию можно отключить.
# backslash_quote = safe_encoding							# Контролирует, может ли одинарная кавычка представляться в виде \' . Может принимать значения: on, off, или safe_encoding.
default_with_oids = on 										# Контролирует, включают ли CREATE TABLE и CREATE TABLE AS столбец OID в новую таблицу, если не указано ни WITH OIDS, ни WITHOUT OIDS. Также определяет, будет ли включен столбец OID в таблицу, полученную из SELECT INTO.
escape_string_warning = off 								# Если эта опция включена, при появлении обратного слэша (\) в обычном строковом литерале (запись вида '...') и отключенной опции standard_conforming_strings будет выдаваться предупреждение (warning). Значение по умолчанию on.
# lo_compat_privileges = off
# quote_all_identifiers = off
# sql_inheritance = on 										# Контролирует семантику наследования. Если указано значение off, по умолчанию подтаблицы не включаются различными командами: обычно подразумевается ключевое слово ONLY. Эта опция была добавлена для совместимости с версиями до 7.1.
standard_conforming_strings = off
# synchronize_seqscans = on 								# Разрешает синхронизировать последовательные чтения больших таблиц, чтобы конкурирующие процессы читали один и тот же блок примерно в одно и то же время, и, следовательно, разделяли I/O-нагрузку. Если эта опция включена, чтение может начаться с середины таблицы, а затем "зациклиться" в конце, чтобы покрыть все строки, и таким образом синхронизироваться с остальными запущенными процессами чтения. Это может привести к непредсказуемым изменениям в порядке строк, возвращаемых запросами, в которых не указано ORDER BY. Отключение этой опции заставляет PostgreSQL вести себя как в версиях до 8.3, т.е. последовательное чтение будет начинаться только с начала таблицы. Значение по умолчанию on.

# - Совместимость платформ и клиентов -
# transform_null_equals = off 								# Если эта опция включена, выражения вида expr = NULL (или NULL = expr) воспринимаются как expr IS NULL, то есть возвращают true, если выражение имеет пустое значение, и false, если это не так. В соответствии со стандартом SQL, выражение вида expr = NULL всегда должно возвращать пустое значение (unknown). Следовательно, значение по умолчанию off.

#------------------------------------------------------------------------------
# ERROR HANDLING
#------------------------------------------------------------------------------

# exit_on_error = off
# restart_after_crash = on

#------------------------------------------------------------------------------
# Дополнительные опции
#------------------------------------------------------------------------------

# custom_variable_classes = ''								# Эта переменная определяет одно или несколько имён классов, которые будут использоваться для дополнительных переменных. Если имён несколько, они перечисляются через запятую. Дополнительная переменная — это такая переменная, которой обычно нет в PostgreSQL, но которая используется в каком-либо модуле-дополнении. Такие переменные должны иметь имя, состоящее из имени класса, точки и имени переменной. custom_variable_classes определяет все имена классов, используемые для данного сервера.